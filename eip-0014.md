Decentralized Exchange Contracts Standard
=========================================

* Author: kushti, Ilya Oskin
* Status: Proposed
* Created: 12-Mar-2021
* Last edited: 12-Mar-2021
* License: CC0
* Track: Standards 

Motivation 
----------

Act of exchange without trusted parties is a most basic primitive for decentralized finance on top of blockchains. Thus contracts for that were introduced early, and basic single-chain swap contract was introduced early in the [ErgoScript whitepaper](https://ergoplatform.org/docs/ErgoScript.pdf). Then a lot of other order contracts appeared: with partial filling, buyback guarantee and so on. What is good for traders in decentralized worlds, such contracts are usually composable. 
While swap order contracts allows for orderbook-based decentralized exchanges (DEXes), now popular AMM-based DEXes (where AMM stands for Automated Market Maker) also possible on Ergo. 
Interestingly, unlike other known blockchains, thanks to the extended UTXO model, liquidity pool contracts for AMM-based DEXes can be combined with order contracts (for orderbook-based DEXes). This gives unique possibility to have shared liquidity among different types of exchanges on top of the Ergo blockchain. 

This PR provides known DEX contracts for both orderbook-based and AMM-based DEXes, and also provides info on their composability.


Order Contracts
---------------

Order contracts are waiting for another orders to be matched, or for a refund command. Orders can be buy (i.e. buy tokens with ERG), sell (i.e. sell tokens for ERG), or swap (buy non-ERG tokens with other non-ERG tokens) orders.

* simplest orders (from the ErgoScript whitepaper)

	Buy order:

        (HEIGHT > deadline && pkA) || {
	      val tokenData = OUTPUTS(0).R2[Coll[(Coll[Byte], Long)]].get(0)
	      allOf(Coll(
	        tokenData._1 == token1,tokenData._2 >= 60L,
	        OUTPUTS(0).propositionBytes == pkA.propBytes,
	        OUTPUTS(0).R4[Coll[Byte]].get == SELF.id
	      ))
	    }  

	Sell order:

	    (HEIGHT > deadline && pkB) ||
        allOf(Coll(
        	OUTPUTS(1).value >= 100L,
        	OUTPUTS(1).propositionBytes == pkB.propBytes,
        	OUTPUTS(1).R4[Coll[Byte]].get == SELF.id
        ))


* simple swap order ([by Jason Davies](https://blog.plutomonkey.com/2021/01/generic-on-chain-ergo-swaps/))

	Buy order:

        {
          val user_pk = proveDlog(recipient);
          val deadline = SELF.creationInfo._1 + 30;

          val erg_amount = SELF.value - fee;
          val token_amount = erg_amount * rate / divisor;

          val valid_height = HEIGHT < deadline;

          sigmaProp(OUTPUTS.exists({ (box: Box) =>
            allOf(Coll(
              if (valid_height) {
                val t = box.tokens(0);
                t._1 == token_id &&
                t._2 >= token_amount
              } else {
                // refund
                box.value >= erg_amount
              },
              box.R4[Coll[Byte]].get == SELF.id,
              box.propositionBytes == user_pk.propBytes
            ))
          }))
        }


    Sell order: 

        {
          val user_pk = proveDlog(recipient);
          val deadline = SELF.creationInfo._1 + 30;

          val self_tokens = SELF.tokens;
          val token_amount = self_tokens(0)._2;
          val erg_amount = token_amount * rate / divisor;

          val valid_height = HEIGHT < deadline;

          sigmaProp(OUTPUTS.exists({ (box: Box) =>
            allOf(Coll(
              if (valid_height) {
                box.value >= erg_amount
              } else {
                // refund
                box.tokens == self_tokens
              },
              box.R4[Coll[Byte]].get == SELF.id,
              box.propositionBytes == user_pk.propBytes
            ))
          }))
        }

    Swapping two tokens: 
    
        {
          val user_pk = proveDlog(recipient);
          val deadline = SELF.creationInfo._1 + 30;

          val self_tokens = SELF.tokens;
          val token_amount = self_tokens(0)._2;
          val other_token_amount = token_amount * rate / divisor;

          val valid_height = HEIGHT < deadline;

          sigmaProp(OUTPUTS.exists({ (box: Box) =>
            allOf(Coll(
              if (valid_height) {
                val t = box.tokens(0);
                t._1 == other_token_id &&
                t._2 >= other_token_amount
              } else {
                // refund
                box.tokens == self_tokens
              },
              box.R4[Coll[Byte]].get == SELF.id,
              box.propositionBytes == user_pk.propBytes
            ))
          }))
        }    


* orders with partial filling support:

    Buy order:
    
        buyerPk || {

          val tokenPrice = $tokenPrice
          val dexFeePerToken = $dexFeePerToken

          val returnBox = OUTPUTS.filter { (b: Box) => 
            b.R4[Coll[Byte]].isDefined && b.R4[Coll[Byte]].get == SELF.id && b.propositionBytes == buyerPk.propBytes
          }(0)

          val returnTokenData = returnBox.tokens(0)
          val returnTokenId = returnTokenData._1
          val returnTokenAmount = returnTokenData._2
          val maxReturnTokenErgValue = returnTokenAmount * tokenPrice
          val totalReturnErgValue = maxReturnTokenErgValue + returnBox.value
          val expectedDexFee = dexFeePerToken * returnTokenAmount
      
          val foundNewOrderBoxes = OUTPUTS.filter { (b: Box) => 
            b.R4[Coll[Byte]].isDefined && b.R4[Coll[Byte]].get == SELF.id && b.propositionBytes == SELF.propositionBytes
          }

          val coinsSecured = (SELF.value - expectedDexFee) == maxReturnTokenErgValue || {
            foundNewOrderBoxes.size == 1 && foundNewOrderBoxes(0).value >= (SELF.value - totalReturnErgValue - expectedDexFee)
          }

          val tokenIdIsCorrect = returnTokenId == tokenId
    
          allOf(Coll(
            tokenIdIsCorrect,
            returnTokenAmount >= 1,
            coinsSecured
          ))
        }

    Sell order:
    
        sellerPk || {
          val tokenPrice = $tokenPrice
          val dexFeePerToken = $dexFeePerToken

          val selfTokenAmount = SELF.tokens(0)._2

          val returnBox = OUTPUTS.filter { (b: Box) => 
            b.R4[Coll[Byte]].isDefined && b.R4[Coll[Byte]].get == SELF.id && b.propositionBytes == sellerPk.propBytes
          }(0)
      
          val foundNewOrderBoxes = OUTPUTS.filter { (b: Box) => 
            b.R4[Coll[Byte]].isDefined && b.R4[Coll[Byte]].get == SELF.id && b.propositionBytes == SELF.propositionBytes
          }

          (returnBox.value == selfTokenAmount * tokenPrice) || {
            foundNewOrderBoxes.size == 1 && {
              val newOrderBox = foundNewOrderBoxes(0)
              val newOrderTokenData = newOrderBox.tokens(0)
              val newOrderTokenAmount = newOrderTokenData._2
              val soldTokenAmount = selfTokenAmount - newOrderTokenAmount
              val minSoldTokenErgValue = soldTokenAmount * tokenPrice
              val expectedDexFee = dexFeePerToken * soldTokenAmount

              val newOrderTokenId = newOrderTokenData._1
              val tokenIdIsCorrect = newOrderTokenId == tokenId

              tokenIdIsCorrect && soldTokenAmount >= 1 && newOrderBox.value >= (SELF.value - minSoldTokenErgValue - expectedDexFee)
            }
          }
        }    

Liquidity Pool Contracts
------------------------

An AMM pool is a contract fulfilling orders. Basic operations (after pool bootstrapping) are add liquidity and remove liquduity.


* ErgoSwap V. 1 Contracts
 
  Pool contract:

  