# ErgoFund contracts

* Author: kushti
* Status: Proposed
* Created: 11-June-2021
* License: CC0
* Forking: not needed 

## Motivation 

Collecting funds in different contexts is very much needed for building common infrastructure and applications
 in the Ergo ecosystem. This EIP is proposing contracts and standardized box formats for announcing 
 crowdfunding campaigns and collecting funds.

## Overall Design

The design of the crowdfunding contracts and box templates below is centered around 
efficiency of blockchain scanning by an offchain application (backend of ErgoFund service built on top of the Scanner,
). 

## Campaign Registration

Crowdfunding campaign registration is controlled by a control box associated with an NFT which registers R4 and R5 
contain registration price and address (script) to pay for campaign registration.

Control box:

Contains campaign registration price in register R4 (as long value) and script to pay for registration in register R5 
(as byte array).

To register a new crowdfunding campaign, crowdfunding token must be bought (to compensate expenses for scanning, 
storing crowdfunding data, doing an UI) 

Sell contract:

```scala
{
 val controlBox = CONTEXT.dataInputs(0)
 
 val firstUnusedCampaignId = SELF.R4[Int].get
 
 // check control box NFT
 val properControlBox = controlBox.tokens(0)._1 == fromBase64("yIvSlx5W4Mc9SNf9xGbv4GiktkzfGbXunzjxzYUN4z4=")

 val price = controlBox.R4[Long].get 
 val script = controlBox.R5[SigmaProp].get


 val inTokensCount = SELF.tokens(1)._2
 
 val selfOut = OUTPUTS(0)
 
 val validNFT = selfOut.tokens(0)._1 == fromBase64("HiS07HwkSWJzfT9Y7IOkRKoP1F8lBbQJ6ks8m6hCexI=") 
 val tokenId = selfOut.tokens(1)._1 // token the contract is selling
 val validOutTokenId = tokenId == fromBase64("e2oiizI+3iNhwC1632YiTHm2otIHXmODS5iIbkAEgC8=") 
 val outTokensCount = selfOut.tokens(1)._2

 val validTokens = validNFT && validOutTokenId && (outTokensCount == inTokensCount - 1)

 val validScript = SELF.propositionBytes == selfOut.propositionBytes

 val validCampaignIdUpdate = selfOut.R4[Int].get == (firstUnusedCampaignId + 1)

 val rewardOut = OUTPUTS(1) 
 val validPayment = rewardOut.value >= 10000000000L && rewardOut.propositionBytes == script.propBytes
 
 val campaignOut = OUTPUTS(2)
 val validCampaign = campaignOut.tokens(0)._1 == tokenId && campaignOut.R4[Int].get == firstUnusedCampaignId
 

 properControlBox && validTokens && validScript && validPayment && validCampaignIdUpdate && validCampaign
}
```


Control box NFT id: c88bd2971e56e0c73d48d7fdc466efe068a4b64cdf19b5ee9f38f1cd850de33e
Tokensale box NFT id: 1e24b4ec7c244962737d3f58ec83a444aa0fd45f2505b409ea4b3c9ba8427b12
Campaign identification token: 7b6a228b323ede2361c02d7adf66224c79b6a2d2075e63834b98886e4004802f

Tokensale box P2S address: L7uDNCg9r1Zp6JUTJGEtnb6pPogTDs7Bxm4NUK94PXnhS6se7Mungk1g8a5NA3qwNeJi8mtj7aHmTrUzEe4ErZp2PZLcKAHC2LEdQHMrS8Y68x9wLVqbD5PocKNfD5hGrm3NZAecWmK47QWXSFuJG6M2ciUiVggXiR3Gr1nidtjT5VogZcuUjWHBMyXCh3hCtyaQA3icbAQaJSM2g1GyiFcyZrCFpn1P5B2j2JDGMSSCzQfpgueoC5yN5GMh6Hgwz7YGr7uvAQkFsfLLMAg9HKY7XzCByAUQVdDGetYhNngazmP1YDdaZ5U5VUg1TRtCYBsyZk1JYPJGBRTq5j2zcFLhcZkZBwBs92kp7BpGZcTe8vHvBnRv8h3jfUxGZ4K1h68SiH6Q6mbyvHyNz6vB3PgocArMKBbzAQzCpJio5BoS

So to register campaign, one need to pass control box as a data input, sell contract among inputs, and create a box with 
campaign box data specified below in outputs.

## Campaign Box Data

For campaign, it is enough just to create box with ErgoFund token, campaign ID, campaign desc, script, recommended deadline, min to raise.

value >= 1 ERG (1000000000 nanoERG)
script = "4MQyMKvMbnCJG3aJ" (false proposition, so no one can spend)

*R4* - campaign ID (Int)
*R5* - campaign desc (byte array)
*R6* - campaign script (funds collected will go to this)
*R7* - fundraising deadline (Int, # of block, exclusive) 
*R8* - min value for successful fundraising (Long)  

https://explorer.ergoplatform.com/en/transactions/2e25bc0ea4d01108ab1cd76969f49022228b533a2ea50540f6cde6258029a510


example:

```json
[
  {
    "address": "4MQyMKvMbnCJG3aJ",
    "value": 100000000,
    "assets": [
      {
        "tokenId": "08fc8bd24f0eaa011db3342131cb06eb890066ac6d7e6f7fd61fcdd138bd1e2c",
        "amount": 1
      }
    ],
    "registers": {
      "R4": "0400",
      "R5": "0e00",
      "R6": "08cd0327e65711a59378c59359c3e1d0f7abe906479eccb76094e50fe79d743ccc15e6",
      "R7": "04a0be49",
      "R8": "0580d0acf30e"
    }
  }
]
```

## Pledge Contract

```scala
{
   val campaignId = SELF.R4[Int].get
   val backerPubKey = SELF.R5[SigmaProp].get
   val projectPubKey = SELF.R6[SigmaProp].get
   val deadline = SELF.R7[Int].get // height
   val minToRaise = SELF.R8[Long].get

   val fundraisingFailure = HEIGHT >= deadline && OUTPUTS(0).propositionBytes == backerPubKey.propBytes && OUTPUTS(0).value >= SELF.value 
   val enoughRaised = {(outBox: Box) => outBox.value >= minToRaise && outBox.propositionBytes == projectPubKey.propBytes && outBox.R4[Int].get == campaignId}

   val fundraisingSuccess = HEIGHT < deadline && enoughRaised(OUTPUTS(0))
   fundraisingFailure || fundraisingSuccess
}
```

address: XUFypmadXVvYmBWtiuwDioN1rtj6nSvqgzgWjx1yFmHAVndPaAEgnUvEvEDSkpgZPRmCYeqxewi8ZKZ4Pamp1M9DAdu8d4PgShGRDV9inwzN6TtDeefyQbFXRmKCSJSyzySrGAt16 

*R4* - campaign ID (Int)
*R5* - backer script
*R6* - campaign script (funds collected will go to this)
*R7* - fundraising deadline (Int, # of block, inclusive) 
*R8* - min value for successful fundraising (Long)


## TO-DO

* Contracts to collect funds in SigUSD and other tokens.  
* Contracts for campaigns with thousands of pledges.