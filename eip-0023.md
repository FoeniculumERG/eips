# Oracle Pool v2.0 

This is a proposed update to the oracle pool 1.0 currently deployed and documented in [EIP16](https://github.com/ergoplatform/eips/blob/eip16/eip-0016.md).

Oracle pool 1.0 has the following drawbacks:

1. Rewards generate a lot of dust
2. Current rewards are too low (related to 1)
3. There are two types of oracle pool boxes. This makes dApps and update mechanism more complex
4. Participant tokens are non-transferable, and so oracles are locked permanently. The same goes with ballot tokens.

Oracle pool 2.0 aims to address the above. 

Below is a summary of the main new features in 2.0 and how it differs from 1.0.

1. Single pool address (only one type of box). This version of the pool will have only one address, the *pool address*. 
2. Data-point boxes will be considered as inputs rather than data-inputs. These inputs will be spent, and a copy of the box with the reward will be created.
3. Reward in tokens not Ergs. The posting reward will be in the form of tokens, which can be redeemed separately. 
4. Reward accumulated in data point boxes to prevent dust. We will not be creating a new box for rewarding each posting. Instead, the rewards will be accumulated in data-point boxes.
5. When creating a data-point box, the pool box is not needed as data input. Creating a data-point will be decoupled from the pool, and will not require the bool box as data-input. 
6. Update mechanism as before. We will have the same update mechanism as in v1.0
7. Transferable participant tokens. Participant tokens are free to be transferred between public keys
8. Longer epoch period (1 hour or 30 blocks).
9. No separate funding box. The pool box emits only reward tokens and won't be handing out Ergs. Thus, there won't be a separate funding process required. 
10. Reward mechanism separate from pool. The process of redeeming the reward tokens is not part of the protocol.
11. Pool box is separated from the logic of pool management, which is captured instead in a **refresh** box. This makes the pool box very small for use in other dApps.

## Reward Mechanism 

In 1.0, the pool was responsible for rewarding each participant for posting a data-point. In 2.0, the pool simply certifies that a data-point was posted, and a separate reward mechanism is proposed. This keeps the contract smaller and more flexible.

The certificates are in the form of tokens emitted by the pool box. Once there are sufficient number of such tokens, a participant
can exchange or burn them in return for a reward. We also give a sample token exchange contract. 

## Design

In this section we describe the high level design of the system. This will include the tokens used, the contracts and the transactions.

### Tokens

The system has the following types of tokens. Note that we use the term **NFT** to refer to any token that was issued in quantity 1.

| Token | Issued quantity | purpose | where stored |
|---|---|---|---|
|Pool-NFT | 1 | Identify pool box | Pool box |
|Refresh-NFT | 1 | Identify refresh box | Refresh box |
|Update-NFT | 1 | Identify update box | Update box |
|Participant tokens | 15 | Identify each participant box | Participant boxes |
|Ballot tokens | 15 | Identify each ballot box | Ballot boxes |
|Reward tokens | 100 million | Reward participants | Refresh box <br> Participant boxes |

### Contracts and boxes
There are a total of 5 contracts and so 5 types of boxes as mentioned below

| Contract name | How many boxes? | Token in boxes | Important  Registers | Purpose | Transactions |
|---|---|---|---|---|---|
|Pool | 1 | Pool-NFT| R3: Creation height (Int) <br> R4: Rate (Long) <br> R5: Epoch counter (Int) | Publish pool rate for dApps | Refresh pool | 
|Refresh| 1 | Refresh-NFT <br> Reward tokens| | Refresh pool box | Refresh pool <br> Update pool |
|Participant | 15 | Participant token <br> Reward tokens | R4: Public key (GroupElement) <br> R5: Pool box Id (Coll[Byte])<br> R6: Published rate (Long) |Publish data-point <br> Accumulate reward | Publish data-point <br> Refresh pool <br> Transfer token <br> Redeem reward |
|Update | 1 | Update-NFT | Updating refresh box | Update refresh box |
|Ballot | 15 | Ballot token | R4: Public key (GroupElement) <br> R5: Update box Id (Coll[Byte]) <br> R6: New refresh box hash (Coll[Byte]) | Voting for updating refresh box | Vote for update <br> Update pool |


### Transactions

Oracle pool 2.0 has the following transactions. 
Each of the transactions below is also assumed to have the following boxes which will not be shown.

1. Funding box: this will be used to fund the transaction, and will be the last input
2. Fee box:  this will be the last box
3. Change box: this is optional, and if present, will be the second last box.

| Trasactions | Boxes Involved | Purpose |
| --- | --- | --- |
| Refresh pool | Pool <br> Refresh <br> Participants | Refresh pool rate |
| Publish data point | Participant | Publish data point for refresh |
| Redeem reward | Participant | Redeem rewards obtained via publishing rate | 
| Transfer token | Participant | Transfer participant token to another public key |
| Vote for update | Ballot | Vote for updating refresh box |
| Update refresh box | Update <br> Refresh <br> Ballots | Update refresh box |

None of the transactions have data-inputs.

## Transaction Structure 

### Refresh pool

| Index | Input | Output |
|---|---|---|
| 0 | Pool | Pool |  
| 1 | Refresh | Refresh |  
| 2 | Participant 1 | Participant 1 |  
| 3 | Participant 2 | Participant 2 |  
| 4 | Participant 3 | Participant 3 |  
| ... | ... | ... |

The participant boxes **must be sorted in increasing order** of their R4 (Long) value.

### Publish data-point

| Index | Input | Output |
|---|---|---|
| 0 | Participant | Participant |  

### Transfer participant token

| Index | Input | Output |
|---|---|---|
| 0 | Participant | Participant |  

### Vote for update

| Index | Input | Output |
|---|---|---|
| 0 | Ballot | Ballot |  

### Update refresh box

| Index | Input | Output |
|---|---|---|
| 0 | Update | Update |  
| 1 | Refresh | Refresh |  
| 2 | Ballot 1 | Ballot 1 |  
| 3 | Ballot 2 | Ballot 2 |  
| 4 | Ballot 3 | Ballot 3 |  
| ... | ... | ... |


## Pool Contract

```scala
{ // This box (pool box)
  //   R4 Current data point (Long)
  //   epoch start height is stored in creation Height (R3)
  // 
  //   tokens(0) pool token (NFT)
  
  val refreshNFT = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual

  sigmaProp(INPUTS(1).tokens(0)._1 == refreshNFT)
}
```
## Refresh Contract

```scala
{ // This box (refresh box)
  //   tokens(0) reward tokens to be emitted (several) 
  //   
  //   When initializing the box, there must be one reward token. When claiming reward, one token must be left unclaimed   
  
  val participantTokenId = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual
  val updateNFT = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual 
  val poolNFT = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual 
  
  val poolAction = if (getVar[Any](0).isDefined) {
    val spenderIndex = getVar[Int](0).get // the index of the data-point box (NOT input!) belonging to spender    

    val epochLength = 30 // 1 hour 
    val minStartHeight = HEIGHT - epochLength
    val minDataPoints = 4
    val buffer = 4 
    val maxDeviationPercent = 5 // percent

    val poolIn = INPUTS(0)
    val poolOut = OUTPUTS(0)
    val selfOut = OUTPUTS(1)

    def isValidDataPoint(b: Box) = if (b.R5[Any].isDefined) {
      b.creationInfo._1    >= minStartHeight &&  // data point must not be too old
      b.tokens(0)._1       == participantTokenId && // first token id must be of participant token
      b.R5[Coll[Byte]].get == poolIn.id // it must correspond to this epoch
    } else false
          
    val dataPoints = INPUTS.filter(isValidDataPoint)    
    val pubKey = dataPoints(spenderIndex).R4[GroupElement].get

    val enoughDataPoints = dataPoints.size >= minDataPoints    
    val rewardEmitted = dataPoints.size * 2 // one extra token for each collected box as reward to collector   
    val epochOver = poolIn.creationInfo._1 <= minStartHeight
       
    val startData = 1L // we don't allow 0 data points
    val startSum = 0L 
    // we expected datapoints to be sorted in INCREASING order

    val lastSortedSum = dataPoints.fold((startData, (true, startSum)), {
        (t: (Long, (Boolean, Long)), b: Box) =>
           val currData = b.R6[Long].get
           val prevData = t._1
           val wasSorted = t._2._1 
           val oldSum = t._2._2
           val newSum = oldSum + currData  // we don't have to worry about overflow, as it causes script to fail

           val isSorted = wasSorted && prevData <= currData 

           (currData, (isSorted, newSum))
      }
    )
 
    val lastData = lastSortedSum._1
    val isSorted = lastSortedSum._2._1
    val sum = lastSortedSum._2._2
    val average = sum / dataPoints.size 

    val maxDelta = lastData * maxDeviationPercent / 100          
    val firstData = dataPoints(0).R6[Long].get

    sigmaProp(proveDlog(pubKey))                                  &&
    enoughDataPoints                                              &&    
    isSorted                                                      &&
    lastData - firstData     <= maxDelta                          && 
    poolIn.tokens(0)._1      == poolNFT                           &&
    poolOut.tokens           == poolIn.tokens                     && // preserve pool tokens
    poolOut.R4[Long].get     == average                           && // rate
    poolOut.R5[Int].get      == poolIn.R5[Int].get + 1            && // counter
    poolOut.propositionBytes == poolIn.propositionBytes           && // preserve pool script
    poolOut.value            >= poolIn.value                      &&
    poolOut.creationInfo._1  >= HEIGHT - buffer                   && // ensure that new box has correct start epoch height
    selfOut.tokens(0)        == SELF.tokens(0)                    && // refresh NFT preserved
    selfOut.tokens(1)._1     == SELF.tokens(1)._1                 && // reward token id preserved
    selfOut.tokens(1)._2     == SELF.tokens(1)._2 - rewardEmitted && // reward token amount correctly reduced
    selfOut.tokens.size      == 2                                 && // no more tokens
    selfOut.propositionBytes == SELF.propositionBytes             && // script preserved
    selfOut.value            >= SELF.value                           // Ergs preserved &&
  } else false

  val updateAction = INPUTS(0).tokens(0)._1 == updateNFT 
  
  poolAction || updateAction
}
```

## Participant contract

```scala
{ // This box (participant box)
  //   R4 public key (GroupElement)
  //   R5 box id of pool box (Coll[Byte])
  //   R6 data point (Long)

  //   tokens(0) participant token (one)
  //   tokens(1) reward tokens collected (one or more) 
  //   
  //   When initializing the box, there must be one reward token. When claiming reward, one token must be left unclaimed

  val poolNFT = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual 
  val minStorageRent = 100000000
  val selfPubKey = SELF.R4[GroupElement].get
  val selfIndex = getVar[Int](0).get
  val output = OUTPUTS(selfIndex)

  val isSimpleCopy = output.tokens(0) == SELF.tokens(0) && // participant token is preserved
                     output.tokens(1)._1 == SELF.tokens(1)._1 && // reward tokenId is preserved
                     output.tokens.size == 2 && // exactly two token types
                     output.propositionBytes == SELF.propositionBytes && // script preserved
                     output.R4[GroupElement].isDefined // output must have a public key (not necessarily the same)
                     
  val collection = INPUTS(0).tokens(0)._1 == poolNFT && // first input must be pool box
                   output.tokens(1)._2 > SELF.tokens(1)._2 && // at least one reward token must be added 
                   output.R4[GroupElement].get == selfPubKey && // for collection preserve public key
                   output.value >= SELF.value // nanoErgs value preserved
                   output.R5[Any].isDefined == false // no more registers

  val owner = proveDlog(selfPubKey) &&
              output.value >= minStorageRent

  // owner can choose to transfer to another public key by setting different value in R6
  isSimpleCopy && (owner || collection) 
}
```

## Ballot Contract

```scala
{ // This box (ballot box):
  // R4 the group element of the owner of the ballot token [GroupElement]
  // R5 the box id of the update box [Coll[Byte]]
  // R6 the value voted for [Coll[Byte]]

  // Base-64 version of the update NFT 720978c041239e7d6eb249d801f380557126f6324e12c5ba9172d820be2e1dde 
  // Got via http://tomeko.net/online_tools/hex_to_base64.php
  val updateNFT = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual 

  val pubKey = SELF.R4[GroupElement].get
  
  val output = OUTPUTS(0)
  
  val isBasicCopy = SELF.id == INPUTS(0).id && 
                    output.R4[GroupElement].isDefined && 
                    output.propositionBytes == SELF.propositionBytes &&
                    output.tokens == SELF.tokens && 
                    output.value >= 10000000 // minStorageRent 
  
  sigmaProp(
    isBasicCopy && (
      proveDlog(pubKey) || (
         INPUTS(0).tokens(0)._1 == updateNFT && 
         output.R4[GroupElement].get == pubKey &&
         output.value >= SELF.value
      )
    )
  )
}
```

## Update Contract

```scala
{ // This box (update box):
  // Registers empty 
  // 
  // ballot boxes (Inputs)
  // R4 the pub key of voter [GroupElement] (not used here)
  // R5 the box id of this box [Coll[Byte]]
  // R6 the value voted for [Coll[Byte]]

  val refreshNFT = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual 

  val ballotTokenId = fromBase64("ERERERERERERERERERERERERERERERERERERERERERE=") // TODO replace with actual 

  // collect and update in one step
  val updateBoxOut = OUTPUTS(0) // copy of this box is the 1st output
  val validUpdateIn = SELF.id == INPUTS(0).id // this is 1st input

  val refreshBoxIn = INPUTS(1) // pool box is 2nd input
  val refreshBoxOut = OUTPUTS(1) // copy of pool box is the 2nd output
  
  // compute the hash of the pool output box. This should be the value voted for
  val refreshBoxOutHash = blake2b256(refreshBoxOut.propositionBytes)
  
  val validRefreshIn = refreshBoxIn.tokens(0)._1 == refreshNFT
  val validRefreshOut = refreshBoxIn.tokens == refreshBoxOut.tokens &&
                        refreshBoxIn.value == refreshBoxOut.value 

  
  val validUpdateOut = SELF.tokens == updateBoxOut.tokens && 
                       SELF.propositionBytes == updateBoxOut.propositionBytes &&
                       SELF.value <= updateBoxOut.value 

  def isValidBallot(b:Box) = {
    b.tokens.size > 0 && 
    b.tokens(0)._1 == ballotTokenId &&
    b.R5[Coll[Byte]].get == SELF.id && // ensure vote corresponds to this box ****
    b.R6[Coll[Byte]].get == refreshBoxOutHash // check value voted for
  }
  
  val ballotBoxes = INPUTS.filter(isValidBallot)
  
  val votesCount = ballotBoxes.fold(0L, {(accum: Long, b: Box) => accum + b.tokens(0)._2})
  
  sigmaProp(validRefreshIn && validRefreshOut && validUpdateIn && validUpdateOut && votesCount >= 8) // minVotes = 8 
}
```
